defmodule BeepBop do
  alias Ecto.Multi
  
  defmacro __using__(opts) do
    unless Keyword.has_key?(opts, :ecto_repo) do
      raise(ArgumentError, message: ~s{

Please configure an Ecto.Repo by passing an Ecto.Repo like so:
    use BeepBop, ecto_repo: YourProject.Repo
})
    end

    quote do
      import BeepBop
      alias Ecto.Multi

      @repo_opts nil
      @beepbop_repo Keyword.fetch!(unquote(opts), :ecto_repo)
    end
  end

  defmacro state_machine(schema, column, do: block) do
    {:__aliases__, _, module_list} = schema

    quote location: :keep do
      
      if @repo_opts == nil, do: @repo_opts([])

      @beepbop_state_column unquote(column)
      @beepbop_schema_module unquote(schema)
      @beepbop_schema_name unquote(module_list)
                           |> List.last()
                           |> Atom.to_string()
                           |> String.downcase()
                           |> String.to_atom()

      defp _beepbop_extract_struct(context) do
        case Map.fetch(context, @beepbop_schema_name) do
          {:ok, %unquote(schema){} = struct} ->
            struct

          {:ok, _} ->
            nil

          :error ->
            nil
        end
      end

      defp _beepbop_try_persist(multi, struct, to_state) do
        Multi.run(multi, :persist, fn changes ->
          updated_struct = _beepbop_extract_struct(changes) || struct

          try do
            __MODULE__.persist(struct, to_state)
          rescue
            UndefinedFunctionError ->
              {:ok, Map.put(updated_struct, @beepbop_state_column, to_state)}
          end
        end)
      end

      unquote(block)
    end
  end

  defmacro states(states) do
    quote do
      @doc """
      Returns the list of defined states in this machine.
      """
      @spec states :: [atom]
      def states() do
        unquote(states)
      end

      @doc """
      Checks if given `state` is defined in this machine.
      """
      @spec state_defined?(atom) :: boolean
      def state_defined?(state) do
        Enum.member?(states(), state)
      end

      @doc """
      Validates the `context` and checks if the transition is valid.

      The `context` must contain a struct of type `#{@beepbop_schema_module}`
      under the `:#{@beepbop_schema_name}` key.
      """
      def validate_transition(context, from_states, to_state, event) do
        case _beepbop_extract_struct(context) do
          nil ->
            "#{@beepbop_schema_module} struct is missing from `context`"

          struct ->
            current_state = Map.fetch!(struct, @beepbop_state_column) |> String.to_atom()

            if state_defined?(to_state) && Enum.member?(from_states, current_state) do
              :ok
            else
              "Cannot transition from '#{current_state}' to '#{to_state}' via '#{event}'"
            end
        end
      end
    end
  end

  defmacro event(event, options, callback) do
    quote location: :keep do
      @doc """
      Runs the defined callback.

      This function was generated by the `BeepBop.event/3` macro.
      """
      @spec unquote(event)(map, keyword) :: {:ok, map | struct} | {:error, term}
      def unquote(event)(context, opts \\ []) do
        persist? = Keyword.get(opts, :persist, true)
        repo_opts = Keyword.get(opts, :repo, [])
        %{from: from_states, to: to_state} = unquote(options)

        validity = validate_transition(context, from_states, to_state, unquote(event))

        if validity == :ok do
          param =
            case context do
              %BeepBop.State{} = context -> context
              %{} = context -> BeepBop.State.new(context)
            end

          {status, state_struct} = result = unquote(callback).(param)
          schema_struct = _beepbop_extract_struct(context)

          multi =
            _beepbop_try_persist(state_struct.multi, schema_struct, Atom.to_string(to_state))

          if status == :ok and persist? do
            repo = @beepbop_repo()
            repo.transaction(multi, @repo_opts)
          else
            {status, struct(state_struct, multi: multi)}
          end
        else
          {:error, validity}
        end
      end
    end
  end
end
